# 真正的分布式事务解决方案概论

# 分布式事务要解决什么问题
>在单机事务中，数据一旦被提交成功，那么一定能被查询到，但是分布式事务为了保证整体数据的一致性，从提交到能查询到就变得很难实现，比如数据库A提交成功，但是数据库B正在提交，此时此刻发起一个查询B的请求，那么查询出来的数据多半就是老数据了，这显然不满足提交就能被查询的原则。根据单机事务的思想，提交必然能被查询到。且A库提交后，B库要么也一起成功，要么就一起回滚A，B的操作。那么简单来说，强一致性的分布式事务解决方案就是为了解决A已提交的同时，也满足B库的查询得到最新得数据，或者A,B一起回滚。

# 为了解决B查询的到最新数据的问题，将会降低项目的并发量大约20~40%

>在分布式环境中，为了能查到B的最新数据（假设A库已提交的前提）有哪些方案呢？假色现在微服务有serviceA对应A数据库，serviceB对应B数据库（微服务部署，为了负载均衡，一般是多个项目实例，假设这里有serviceA1，serviceA2，serviceB1，serviceB2这么多个部署实例）  
方案概论如下：  
- B库提交事务完成前，阻塞B的所有操作。类似分布式的悲观锁实现。也就是告诉发起查询的调用方，必须等待B提交完成，才能继续执行，这种操作，用独立机器部署的TC事务协调器来实现。
先看伪代码，模拟sql执行前和后的操作。
```java
public static Object excuteSQL(Connection conn, String sql, Object[] params) throws Exception {
        tc.sendSql(sql,params);//发送sql给tc并等待tc响应继续执行的指令。（类似加了一个分布式锁）
        ps = conn.prepareStatement(sql);
        JDBCUtils.setParams(ps, params);
        ps.executeUpdate();//ps.executeQuery();
        tc.sendSqlState("success");//发送sql执行成功的指令给TC协调器。（ps：如果是ps.executeQuery();查询语句，这一步可以省略）
        return object;
}
```
- 要实现B的阻塞操作，那么必须在B完成select操作前，加入一个访问TC协调器的tcp(或rpc)请求(如上面代码)，总之是能保证我要操作，必须得到TC协调器的认可，且不能用本地并发cas控制阻塞。因为B不是单机部署，B是多个实例。所以本地cas在集群多实例情况下失去作用。需要独立于微服务实例之外一个TC实例来做“权限”控制。跟分布式锁的作用相似。

# TC协调器干了那些事情
- TC协调器相当于分布式锁，来控制每个微服务实例中的，本地jdbc底层的执行权限。有权才能去执行，无权只能等待直到超时。  
- http先调用的serviceA，那么最后肯定是由A告诉TC一个commit指令，就好比本地事务一样，得有个commit，那么TC收到commit之后，就加上分布式锁（防止之前说的B查询的脏读的问题），并通知serviceA和serviceB的本地就开始正式执行jdbc的commit 操作（这里两个commit指令，一个是告诉tc，一个是普通的本地commit jdbc代码）。那么显然在TC收到事务执行完成前，所有的sql操作都会被卡住，阻塞。这就是分布式事务所带来的性能消耗。（但是也有优化空间）  
- 如果TC协调器检测到服务B执行本地jdbc提交的时候，失败，则要么让TC协调器代理B继续执行，要么一直通信告诉B继续执行（后者技术实现上，方便一些。TC里面不会有jdbc操作的代码，TC仅做协调作用），直到成功，需要保证事务的幂等性，可以用全局事务id保证。这一点，在没有回滚的前提下，必须得以保证。也满足像单机数据库一样，如果commit之后，数据库宕机了，则其他操作都会失败，除非数据库恢复正常。

# 非常简单的TC协调器有关的优化
- 分布式事务的执行，必须阻塞，而且jdbc底层的执行，必须把权限让给TC来控制，假设现在serviceA真正jdbc commit完成，则应该保证对A的所有查询是允许放权的，也就是A提交后，对A库以后的操作，不受TC的控制，除非此时由开启了一个新的对A的事务请求，那必然又得把A的操作sql锁住。  
- 对TC发起commit之后，如果本地A和B服务的jdbc commit本地执行失败，需要回滚吗？著名的seata框架的方案中实现在A库提交后，任然可以通过undo日志去回滚，又多了一次undo操作，性能消耗，所以我觉得回滚是没必要的，就好比单机中如果jdbc commit成功，意味着数据真实落盘，是无法回滚的，分布式事务中，一旦服务A告诉tc的commit后，则也意味着，数据应该也是瞬间落盘，但现在只不过是"缓慢落盘"的一个过程，这期间其他人都不能操作所有的sql语句。回滚操作在分布式事务中，可以看成是最终服务A并没有发起commit指令告诉TC(或者发送commit指令TC由于网络未收到)，则所有之前的操作因为超时自动清除即可。  
- 可以优化TC的权限控制，仅限制对数据的权限加锁，比如执行update User set name=“新名字”  where userId=1；则只对字段name和userId=1加锁。其他无关的修改事务任然可以并发执行。
# 总结
>分布式事务把本地jdbc任何sql的执行权限交给TC做全局管理，TC检查不存在数据一致性问题时，则放权允许操作。